import { createContext, useContext, useMemo, useState } from "react";

type Language = "en" | "ru";
type DictValue = string | Record<string, DictValue>;

const STORAGE_KEY = "labsync-lang";

const resources: Record<Language, Record<string, DictValue>> = {
  en: {
    common: {
      language: "Language",
      english: "English",
      russian: "Russian",
      board: "Board",
      samples: "Samples",
      actions: "Actions",
      admin: "Admin",
      settings: "Settings",
      warehouse: "Warehouse",
      labOperator: "Lab Operator",
      actionSupervision: "Action Supervision",
      guest: "Guest",
    },
    topBar: {
      searchPlaceholder: "Search samples, analyses, or IDs...",
      searchAria: "Search samples and analyses",
      rolePlaceholder: "Role",
      toggleTheme: "Toggle theme",
      notifications: "Notifications",
      markAllRead: "Mark all as read",
      noNotifications: "No new notifications.",
      signIn: "Sign in",
      logout: "Sign out",
    },
    navigation: {
      backToTop: "Go to top",
    },
    login: {
      signIn: "Sign in",
      subtitle: "Enter your credentials to continue.",
      username: "Username",
      password: "Password",
      rememberMe: "Remember me",
      forgotPassword: "Forgot password?",
      signingIn: "Signing in...",
      hidePassword: "Hide password",
      showPassword: "Show password",
      sessionHint: "Session will end when you sign out or clear browser data.",
      requestSubtitle: "Enter your username and account email. We will send a password reset token.",
      email: "Email",
      sending: "Sending...",
      sendResetToken: "Send reset token",
      backToSignIn: "Back to sign in",
      confirmSubtitle: "Enter reset token and set a new password.",
      resetToken: "Reset token",
      newPassword: "New password",
      confirmNewPassword: "Confirm new password",
      resetting: "Resetting...",
      resetPassword: "Reset password",
      mustChangeSubtitle: "You must set a new password before continuing.",
      currentPassword: "Current password",
      confirmPassword: "Confirm new password",
      updating: "Updating...",
      updatePassword: "Update password",
      errors: {
        loginFailed: "Login failed",
        currentPasswordRequired: "Current password is required.",
        newPasswordMin: "New password must be at least 8 characters.",
        passwordMismatch: "New password and confirmation do not match.",
        passwordChangeFailed: "Password change failed",
        usernameRequired: "Username is required.",
        emailRequired: "Email is required.",
        requestFailed: "Failed to request password reset.",
        resetTokenRequired: "Reset token is required.",
        resetFailed: "Failed to reset password.",
      },
      messages: {
        requestSuccess: "If that email exists, a reset email has been sent.",
        resetSuccess: "Password reset completed. You can now sign in with your new password.",
      },
    },
    admin: {
      toast: {
        failedLoadUsers: "Failed to load users",
        failedLoadEventLog: "Failed to load event log",
        usernameRequired: "Username required",
        fullNameRequired: "Full name required",
        defaultRoleRequired: "Default role required",
        emailRequired: "Email required",
        invalidEmail: "Enter a valid email address",
        userCreated: "User created",
        defaultPassword: "Default password: {{password}}",
        failedCreateUser: "Failed to create user",
        failedDeleteUser: "Failed to delete user",
        usernameUpdated: "Username updated",
        failedUpdateUsername: "Failed to update username",
        fullNameUpdated: "Full name updated",
        failedUpdateFullName: "Failed to update full name",
        emailUpdated: "Email updated",
        failedUpdateEmail: "Failed to update email",
        backendUnreachable: "Backend unreachable",
      },
    },
    settings: {
      title: "Settings",
      systemStatus: "System status",
      subtitle: "Frontend still uses mock data; backend is used for health only.",
      backendReachable: "Backend reachable",
      unexpectedResponse: "Unexpected response",
      failedBackend: "Failed to reach backend",
      checking: "Checking...",
      healthy: "Healthy",
      unavailable: "Unavailable",
      idle: "Idle",
      retry: "Retry",
    },
    board: {
      roleView: {
        warehouse_worker: "Warehouse view: samples and storage",
        lab_operator: "Lab view: analyses",
        action_supervision: "Action supervision view",
        admin: "Admin view",
      },
      sampleTrackingBoard: "Sample Tracking Board",
      samplesAcrossStages: "{{count}} samples across {{stages}} stages",
      methods: "Methods",
      filterVisibility: "Filter visibility",
      changesSaved: "Changes saved",
      filterVisibilityUpdated: "Filter visibility updated.",
      failedUpdateFilters: "Failed to update filters",
      failedLoadData: "Failed to load data",
      sort: "Sort",
      sortOrder: "Sort order",
      reset: "Reset",
      sortBy: "Sort by",
      chooseField: "Choose field",
      sampleId: "Sample ID",
      samplingDate: "Sampling date",
      methodsDone: "Methods Done",
      ascending: "Ascending",
      descending: "Descending",
      cancel: "Cancel",
      apply: "Apply",
      showAssignedOnly: "Show only assigned to me",
      showIncompleteOnly: "Show only incomplete",
      undo: "Undo",
      syncing: "Syncing...",
      refresh: "Refresh",
      addConflict: "Add conflict",
      newSample: "New Sample",
      loadingBoard: "Loading board...",
      noItemsYet: "No items yet. Create a sample or analysis to get started.",
      columns: {
        planned: "Planned",
        awaiting_arrival: "Awaiting arrival",
        stored: "Stored",
        issues: "Issues",
        in_progress: "In progress",
        needs_attention: "Needs attention",
        completed: "Completed",
        uploaded_batch: "Uploaded batch",
        conflicts: "Conflicts",
        deleted: "Deleted",
      },
      card: {
        sample: "Sample",
        analysis: "Analysis",
        conflictStatus: "Conflict status",
        uploadedBatch: "Uploaded batch",
        batch: "Batch",
        conflict: "Conflict",
        conflicts: "Conflicts",
        resolved: "Resolved",
        stored: "Stored",
        sampling: "Sampling",
        well: "Well",
        horizon: "Horizon",
        reason: "Reason",
        returnNote: "Return note",
        issue: "Issue",
        fridge: "Fridge",
        bin: "Bin",
        place: "Place",
        done: "Done",
        delete: "Delete",
        restore: "Restore",
        storedAsNotResolved: "Stored as not-resolved",
        returnForAnalysis: "Return for analysis",
        failed: "Failed",
        unassigned: "Unassigned",
      },
    },
    panel: {
      sampleStatus: "Sample status",
      analysisStatus: "Analysis status",
      latestIssue: "Latest issue",
      latestReturnNote: "Latest return note",
      timeUnavailable: "Time unavailable",
      assignedTo: "Assigned to",
      addAssignee: "Add assignee",
      samplingDate: "Sampling date",
      storage: "Storage",
      resolutionNote: "Resolution note",
      systemNote: "System note",
      issueAndReturnNotes: "Issue & Return Notes",
      issue: "Issue",
      returnNote: "Return note",
      comments: "Comments",
      noCommentsYet: "No comments yet.",
      commentAs: "Comment as",
      unknown: "Unknown",
      writeComment: "Write a comment...",
      addComment: "Add comment",
      assignOperatorToMethod: "Assign operator to method",
      selectMethod: "Select method",
      assignToLabOperator: "Assign to lab operator",
      noOperatorsForMethod: "No operators have permission for this method.",
      methodRequired: "Method is required",
      selectOperator: "Select an operator to assign",
      labAssignOnlySelf: "Lab operator can assign only themselves",
      noEligibleOperators: "No eligible operators for this method",
      assignOperator: "Assign operator",
      addAnalysisAdmin: "Add analysis (Admin)",
      analysisPlaceholder: "e.g. NMR",
      assignOptional: "Assign to (optional)",
      analysisTypeRequired: "Analysis type is required",
      addAnalysis: "Add analysis",
      resolveConflict: "Resolve conflict",
      resolutionNoteOptional: "Resolution note (optional)",
      markResolved: "Mark resolved",
      old: "OLD",
      new: "NEW",
    },
  },
  ru: {
    common: {
      language: "Язык",
      english: "Английский",
      russian: "Русский",
      board: "Доска",
      samples: "Образцы",
      actions: "Воздействия",
      admin: "Админ",
      settings: "Настройки",
      warehouse: "Склад",
      labOperator: "Лаборант",
      actionSupervision: "Контроль воздействий",
      guest: "Гость",
    },
    topBar: {
      searchPlaceholder: "Поиск образцов, анализов или ID...",
      searchAria: "Поиск образцов и анализов",
      rolePlaceholder: "Роль",
      toggleTheme: "Сменить тему",
      notifications: "Уведомления",
      markAllRead: "Отметить все прочитанными",
      noNotifications: "Новых уведомлений нет.",
      signIn: "Вход",
      logout: "Выйти",
    },
    navigation: {
      backToTop: "Наверх",
    },
    login: {
      signIn: "Вход",
      subtitle: "Введите учетные данные для продолжения.",
      username: "Имя пользователя",
      password: "Пароль",
      rememberMe: "Запомнить меня",
      forgotPassword: "Забыли пароль?",
      signingIn: "Вход...",
      hidePassword: "Скрыть пароль",
      showPassword: "Показать пароль",
      sessionHint: "Сессия завершится после выхода или очистки данных браузера.",
      requestSubtitle: "Введите имя пользователя и email учетной записи. Мы отправим токен сброса пароля.",
      email: "Эл. почта",
      sending: "Отправка...",
      sendResetToken: "Отправить токен сброса",
      backToSignIn: "Назад ко входу",
      confirmSubtitle: "Введите токен сброса и задайте новый пароль.",
      resetToken: "Токен сброса",
      newPassword: "Новый пароль",
      confirmNewPassword: "Подтвердите новый пароль",
      resetting: "Сброс...",
      resetPassword: "Сбросить пароль",
      mustChangeSubtitle: "Перед продолжением необходимо установить новый пароль.",
      currentPassword: "Текущий пароль",
      confirmPassword: "Подтвердите новый пароль",
      updating: "Обновление...",
      updatePassword: "Обновить пароль",
      errors: {
        loginFailed: "Не удалось войти",
        currentPasswordRequired: "Требуется текущий пароль.",
        newPasswordMin: "Новый пароль должен содержать не менее 8 символов.",
        passwordMismatch: "Новый пароль и подтверждение не совпадают.",
        passwordChangeFailed: "Не удалось изменить пароль",
        usernameRequired: "Требуется имя пользователя.",
        emailRequired: "Требуется email.",
        requestFailed: "Не удалось запросить сброс пароля.",
        resetTokenRequired: "Требуется токен сброса.",
        resetFailed: "Не удалось сбросить пароль.",
      },
      messages: {
        requestSuccess: "Если такой email существует, письмо для сброса пароля отправлено.",
        resetSuccess: "Пароль сброшен. Теперь войдите с новым паролем.",
      },
    },
    admin: {
      toast: {
        failedLoadUsers: "Не удалось загрузить пользователей",
        failedLoadEventLog: "Не удалось загрузить журнал событий",
        usernameRequired: "Требуется имя пользователя",
        fullNameRequired: "Требуется полное имя",
        defaultRoleRequired: "Требуется роль по умолчанию",
        emailRequired: "Требуется email",
        invalidEmail: "Введите корректный email",
        userCreated: "Пользователь создан",
        defaultPassword: "Пароль по умолчанию: {{password}}",
        failedCreateUser: "Не удалось создать пользователя",
        failedDeleteUser: "Не удалось удалить пользователя",
        usernameUpdated: "Имя пользователя обновлено",
        failedUpdateUsername: "Не удалось обновить имя пользователя",
        fullNameUpdated: "Полное имя обновлено",
        failedUpdateFullName: "Не удалось обновить полное имя",
        emailUpdated: "Email обновлен",
        failedUpdateEmail: "Не удалось обновить email",
        backendUnreachable: "Бэкенд недоступен",
      },
    },
    settings: {
      title: "Настройки",
      systemStatus: "Состояние системы",
      subtitle: "Фронтенд пока использует мок-данные; бэкенд используется только для health-проверки.",
      backendReachable: "Бэкенд доступен",
      unexpectedResponse: "Неожиданный ответ",
      failedBackend: "Не удалось связаться с бэкендом",
      checking: "Проверка...",
      healthy: "Доступен",
      unavailable: "Недоступен",
      idle: "Ожидание",
      retry: "Повторить",
    },
    board: {
      roleView: {
        warehouse_worker: "Склад: образцы и хранение",
        lab_operator: "Лаборатория: анализы",
        action_supervision: "Контроль воздействий",
        admin: "Админ",
      },
      sampleTrackingBoard: "Доска отслеживания образцов",
      samplesAcrossStages: "{{count}} образцов на {{stages}} этапах",
      methods: "Методы",
      filterVisibility: "Видимость фильтров",
      changesSaved: "Изменения сохранены",
      filterVisibilityUpdated: "Видимость фильтров обновлена.",
      failedUpdateFilters: "Не удалось обновить фильтры",
      failedLoadData: "Не удалось загрузить данные",
      sort: "Сортировка",
      sortOrder: "Порядок сортировки",
      reset: "Сброс",
      sortBy: "Сортировать по",
      chooseField: "Выберите поле",
      sampleId: "ID образца",
      samplingDate: "Дата отбора",
      methodsDone: "Выполнено методов",
      ascending: "По возрастанию",
      descending: "По убыванию",
      cancel: "Отмена",
      apply: "Применить",
      showAssignedOnly: "Показывать только назначенные мне",
      showIncompleteOnly: "Показывать только незавершенные",
      undo: "Отменить",
      syncing: "Синхронизация...",
      refresh: "Обновить",
      addConflict: "Добавить конфликт",
      newSample: "Новый образец",
      loadingBoard: "Загрузка доски...",
      noItemsYet: "Пока нет записей. Создайте образец или анализ.",
      columns: {
        planned: "Запланировано",
        awaiting_arrival: "Ожидание поступления",
        stored: "Хранится",
        issues: "Проблемы",
        in_progress: "В работе",
        needs_attention: "Требует внимания",
        completed: "Завершено",
        uploaded_batch: "Загруженная партия",
        conflicts: "Конфликты",
        deleted: "Удалено",
      },
      card: {
        sample: "Образец",
        analysis: "Анализ",
        conflictStatus: "Статус конфликта",
        uploadedBatch: "Загруженная партия",
        batch: "Партия",
        conflict: "Конфликт",
        conflicts: "Конфликты",
        resolved: "Урегулирован",
        stored: "Хранится",
        sampling: "Отбор",
        well: "Скважина",
        horizon: "Горизонт",
        reason: "Причина",
        returnNote: "Комментарий возврата",
        issue: "Проблема",
        fridge: "Холодильник",
        bin: "Ячейка",
        place: "Место",
        done: "Готово",
        delete: "Удалить",
        restore: "Восстановить",
        storedAsNotResolved: "Сохранить как неурегулированное",
        returnForAnalysis: "Вернуть на анализ",
        failed: "Ошибка",
        unassigned: "Не назначен",
      },
    },
    panel: {
      sampleStatus: "Статус образца",
      analysisStatus: "Статус анализа",
      latestIssue: "Последняя проблема",
      latestReturnNote: "Последний комментарий возврата",
      timeUnavailable: "Время недоступно",
      assignedTo: "Назначено",
      addAssignee: "Добавить исполнителя",
      samplingDate: "Дата отбора",
      storage: "Хранение",
      resolutionNote: "Комментарий урегулирования",
      systemNote: "Системная запись",
      issueAndReturnNotes: "Проблемы и комментарии возврата",
      issue: "Проблема",
      returnNote: "Комментарий возврата",
      comments: "Комментарии",
      noCommentsYet: "Комментариев пока нет.",
      commentAs: "Комментировать как",
      unknown: "Неизвестно",
      writeComment: "Введите комментарий...",
      addComment: "Добавить комментарий",
      assignOperatorToMethod: "Назначить оператора на метод",
      selectMethod: "Выберите метод",
      assignToLabOperator: "Назначить лаборанту",
      noOperatorsForMethod: "Нет операторов с правом на этот метод.",
      methodRequired: "Требуется выбрать метод",
      selectOperator: "Выберите оператора для назначения",
      labAssignOnlySelf: "Лаборант может назначить только себя",
      noEligibleOperators: "Нет подходящих операторов для этого метода",
      assignOperator: "Назначить оператора",
      addAnalysisAdmin: "Добавить анализ (Админ)",
      analysisPlaceholder: "напр. NMR",
      assignOptional: "Назначить (необязательно)",
      analysisTypeRequired: "Требуется тип анализа",
      addAnalysis: "Добавить анализ",
      resolveConflict: "Урегулировать конфликт",
      resolutionNoteOptional: "Комментарий урегулирования (необязательно)",
      markResolved: "Отметить урегулированным",
      old: "СТАРОЕ",
      new: "НОВОЕ",
    },
  },
};

type I18nContextType = {
  language: Language;
  setLanguage: (lang: Language) => void;
  t: (key: string, vars?: Record<string, string | number>) => string;
};

const I18nContext = createContext<I18nContextType | undefined>(undefined);

function getInitialLanguage(): Language {
  if (typeof window === "undefined") return "en";
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored === "en" || stored === "ru") return stored;
  return navigator.language.toLowerCase().startsWith("ru") ? "ru" : "en";
}

function resolveKey(dict: Record<string, DictValue>, key: string): string | null {
  const parts = key.split(".");
  let current: DictValue | undefined = dict;
  for (const part of parts) {
    if (!current || typeof current === "string") return null;
    current = current[part];
  }
  return typeof current === "string" ? current : null;
}

function interpolate(text: string, vars?: Record<string, string | number>) {
  if (!vars) return text;
  return text.replace(/\{\{(\w+)\}\}/g, (_, name: string) => String(vars[name] ?? ""));
}

export function I18nProvider({ children }: { children: React.ReactNode }) {
  const [language, setLanguageState] = useState<Language>(getInitialLanguage);

  const setLanguage = (lang: Language) => {
    setLanguageState(lang);
    if (typeof window !== "undefined") {
      localStorage.setItem(STORAGE_KEY, lang);
    }
  };

  const t = (key: string, vars?: Record<string, string | number>) => {
    const selected = resources[language];
    const fallback = resources.en;
    const hit = resolveKey(selected, key) ?? resolveKey(fallback, key) ?? key;
    return interpolate(hit, vars);
  };

  const value = useMemo(() => ({ language, setLanguage, t }), [language]);
  return <I18nContext.Provider value={value}>{children}</I18nContext.Provider>;
}

export function useI18n() {
  const ctx = useContext(I18nContext);
  if (!ctx) throw new Error("useI18n must be used within I18nProvider");
  return ctx;
}
